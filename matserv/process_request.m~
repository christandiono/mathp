function [HttpResponse,code]=process_request(HttpRequest)
    try
        import settings

        for linenumber=1:length(HttpRequest)
            if linenumber==1
                [method,urlpath,protocol]=firstparse(HttpRequest{linenumber});
            end
        end
        
        if ~exist('method','var') || isempty(method) || ~exist('urlpath','var') || isempty(urlpath) || ~exist('protocol','var') || isempty(protocol) || ~any(strcmp(method,settings.ALLOWED_METHODS))
            HttpResponse=make_response(make_header(405));
            return
        end
        
        [localpath, newurlpath, code]=urls(urlpath);
        
        hr=make_header(protocol, code, localpath);
        
        if ~strcmp(method,'HEAD')
            hr{length(hr)+1}=addcontent(localpath);
        else
            hr=hr{1:end-1}; %strip extra linebreak
        end
        HttpResponse=make_response(hr);
        return
    catch e
        import settings
        code=500;
        hr=make_header(protocol, code, localpath);
        if settings.DEBUG && ~isempty(e.message) && ~isempty(e.identifier)
            hr{length(hr)+1}=e.identifier;
            hr{length(hr)+1}=e.message;
        else
            hr{length(hr)+1}='No error info available.';
        end
        HttpResponse=make_response(hr);
        return
    end
end


function HttpResponse=make_response(hr)

    HttpResponse=[hr{1} 13 10];
    for i=2:length(hr)
        HttpResponse=[HttpResponse hr{i} 13 10]; %#ok<AGROW>
    end

end


function [method,urlpath,protocol]=firstparse(line1)

    locations=findstr(line1,' ');

    if length(locations)==2
        method=line1(1:locations(1)-1);
        urlpath=line1(locations(1)+1:locations(2)-1);
        protocol=line1(locations(2)+1:end);
    else
        method='';
        urlpath='';
        protocol='';
    end

end


function content=addcontent(localpath)

% loads content and optionally runs mhp code

privatestruct=struct('starts', starts, 'ends', ends, 'localpath', localpath, 'content', content)

content=fread(fopen(localpath,'r'),inf,'ubit8',0,'n')';

starts=findstr(content, '<?mathp');
ends=findstr(content,'?>');

while ~isempty(starts)
    


    if length(starts)~=length(ends)
        error('MATHP:BadMATHPCode',['There was an error processing ' localpath ' due to bad <?mathp or ?> tag(s).'])
    end
    
    privatestruct=struct('starts', starts, 'ends', ends, 'localpath', localpath, 'content', content);    
    clear starts ends localpath content
    try
        T=evalc(char(privatestruct.content(privatestruct.starts(1)+7:privatestruct.ends(1)-1)));
    catch e
        error('MATHP:BadMATHPCode',['There was an error processing ' privatestruct.localpath ':' 10 e.identifier 10 e.message])
    end

    [starts, ends, localpath, content]=deal(privatestruct.starts, privatestruct.ends, privatestruct.localpath, privatestruct.content);
    
    if starts(1)-1<0
        headpart='';
    else
        headpart=content(1:starts(1)-1);
    end
    
    if ends(1)+2>length(content)
        tailpart='';
    else
        tailpart=content(ends(1)+2:end);
    end
    
    if settings.AUTO_BREAK
        breaks=findstr(T,char(10));
        if ~isempty(breaks)
            T = regexprep(T,char(10),['<br' settings.TAG_END char(10)]);
        end
    end
    
    content=[headpart T tailpart];
    starts=findstr(content, '<?mathp');
    ends=findstr(content,'?>');
end

end